#!/usr/local/bin/node

var bitcore = require('bitcore');
var networks = bitcore.Networks.livenet;
var cmd = process.argv[2];
var argv = process.argv.slice(3, process.argv.length);
var daemon = false;

//arg for daemon
if (cmd == 'daemon') {
    daemon = true;
    argv = argv.slice(1, process.argv.length);
}

//arg for testnet
if (argv[0] == '-t') {
    networks = bitcore.Networks.testnet;
    argv = argv.slice(1, process.argv.length);
}

if (daemon) {
    var http = require('http');
    var url = require('url');

    http.createServer(function (req, res) {

        res.writeHead(200, {'Content-Type': 'application/json'});

        urlData = url.parse(req.url, true);
        data=urlData.query.request;
	
	console.log(data);
        if (typeof data === 'undefined') {
            res.end(fail_output('undefined'));
            return
        }

        var argv = JSON.parse(data);
	console.log(argv);
        cmd = argv[0];
        argv = argv.slice(1, argv.length);

        if (argv[0] == '-t') {
            networks = bitcore.Networks.testnet;
            argv = argv.slice(1, argv.length);
        } else {
            networks = bitcore.Networks.livenet;
        }

        try {
            res.end(success_output(handleRequest(cmd, argv)));
        } catch (err) {
            res.end(fail_output(err.toString()));
        }

    }).listen(1337, '0.0.0.0');
} else {
    try {
        console.log(success_output(handleRequest(cmd, argv)));
    } catch (err) {
        console.log(fail_output(err));
    }
}

function handleRequest(cmd, argv) {
    switch (cmd) {
        case 'create_privatekey':
            return create_private_key();
            break;
        case 'to_address':
            var private_key = argv[0];
            if (private_key == undefined) throw new Error('without private key');
            return create_address(private_key);
            break;
        case 'to_publickey':
            return new bitcore.PrivateKey(argv[0]).toPublicKey().toString();
            break;
        case 'to_multisign_address':
            if (argv[0] == undefined || argv[1] == undefined) throw new Error('Least two private key');
            var threshold = parseInt(argv[argv.length - 1]);
            if (typeof parseInt(threshold) != 'number') throw new Error('without threshold');
            var private_keys = argv.slice(0, argv.length - 1);
            if (private_keys.length < 2) throw new Error('without private keys');
            return create_multisign_address(private_keys, threshold);
            break;
        case 'transaction':
            return transaction(argv[0], argv[1], argv[2], argv[3]);
            break;
        case 'transaction_multisig':
            return transaction_multisig(argv[0], argv[1], argv[2], argv[3], argv[4]);
            break;
        default:
            throw new Error('<command> <arg1> <arg2> ...');
    }
}

function create_private_key() {
    return bitcore.PrivateKey.fromRandom(networks).toWIF();
}

function create_address(private_key) {
    return new bitcore.PrivateKey(private_key, networks).toAddress().toString();
}

function create_multisign_address(private_keys, threshold) {
    var private_keys_obj = privatekey_str_to_obj(private_keys);
    return new bitcore.Address.createMultisig(private_keys_obj, threshold, networks).toString();
}

function privatekey_str_to_obj(private_keys) {
    var private_keys_obj = Array();
    for (var i = 0; i < private_keys.length; i++) {
        private_keys_obj[i] = new bitcore.PrivateKey(private_keys[i]);
    }
    return private_keys_obj;
}

function success_output(data) {
    var result = {};
    result['success'] = true;
    result['data'] = data;
    return JSON.stringify(result);
}

function fail_output(reason) {
    var result = {};
    result['success'] = false;
    result['data'] = null;
    result['reason'] = reason.toString();
    return JSON.stringify(result);
}

function transaction(fromAddress, privateKey, toAddress, amount) {
    var insight = new bitcore.transport.explorers.Insight(networks);
    var amount = bitcore.Unit.fromBTC(amount).toSatoshis();

    insight.getUnspentUtxos(fromAddress, function (err, utxos) {
        if (err) {
            throw new Error(err);
        } else {
            var transaction = new bitcore.Transaction().from(utxos) // Feed information about what unspent outputs one can use
                .to(toAddress, amount) // Add an output with the given amount of satoshis
                .change(fromAddress) // Sets up a change address where the rest of the funds will go
                .sign(privateKey); // Signs all the inputs it can
            insight.broadcast(transaction, function (err, returnedTxId) {
                if (err) {
                    throw new Error(err);
                } else {
                    return returnedTxId;
                }
            });
        }
    });
}

function transaction_multisig(fromAddress, privateKeys, publicKeys, toAddress, amount) {
    var insight = new bitcore.transport.explorers.Insight(networks);
    var amount = bitcore.Unit.fromBTC(amount).toSatoshis();
    for (var i = 0; i < privateKeys.length; i++) {
        publicKeys.push(bitcore.PrivateKey.fromString(privateKeys[i]).toPublicKey().toString());
    }
    insight.getUnspentUtxos(fromAddress, function (err, utxos) {
        if (err) {
            throw new Error(err);
        } else {
            var transaction = new bitcore.Transaction().from(utxos, publicKeys, privateKeys.length) // Feed information about what unspent outputs one can use
                .to(toAddress, amount) // Add an output with the given amount of satoshis
                .change(fromAddress) // Sets up a change address where the rest of the funds will go
                .sign(privateKeys); // Signs all the inputs it can
            insight.broadcast(transaction, function (err, returnedTxId) {
                if (err) {
                    throw new Error(err);
                } else {
                    return returnedTxId;
                }
            });
        }
    });
}
